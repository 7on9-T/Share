Title: 内存操作&汇编
Date: 2021-05-11 16:00
Category: 学习笔记

#内存操作

1. 内存地址：内存地址是指存储器中某一位置的唯一标识符，它由两个部分组成：段地址和偏移地址。段地址指示存储器中某一段的起始地址，偏移地址指示在段内的偏移位置。

2. 内存读写：内存读写是指从内存中读取或写入数据。读取数据时，CPU向内存发出读指令，将要读取的内存地址告诉它，然后CPU等待数据到来，并将数据从内存中读出。写入数据时，CPU向内存发出写指令，将要写入的内存地址和要写入的数据告诉它，然后CPU等待数据写入完成。

3. 内存映射：内存映射是指将物理内存映射到虚拟内存，使得虚拟内存中的程序可以像访问实际物理内存一样访问内存。

4. 内存保护：内存保护是指控制内存访问权限，防止恶意程序或病毒对系统造成破坏。

5. 内存管理：内存管理是指自动分配和回收内存，确保内存的有效利用。

6. 内存碎片：内存碎片是指内存中存在未被利用的空间，导致程序运行效率下降。

7. 内存泄漏：内存泄漏是指程序运行过程中，由于某些原因导致内存泄漏，导致系统资源不足，最终导致系统崩溃。

8. 内存分配：内存分配是指在程序运行过程中，动态地分配内存，以满足程序的需要。

9. 内存释放：内存释放是指在程序运行过程中，释放不再使用的内存，以便系统回收资源。

10. 内存对齐：内存对齐是指将数据结构按一定字节对齐，以便提高内存访问效率。

11. 内存池：内存池是指在程序运行过程中，预先分配一块内存，然后在需要时从内存池中分配内存，并在不需要时释放内存，以节省内存分配和释放的时间。

12. 内存池管理：内存池管理是指在程序运行过程中，管理内存池，确保内存池中的内存分配和释放正确。

13. 内存池分配：内存池分配是指在程序运行过程中，从内存池中分配内存，以节省内存分配的时间。

14. 内存池释放：内存池释放是指在程序运行过程中，释放不再使用的内存，以便系统回收资源。

15. 内存池回收：内存池回收是指在程序运行过程中，回收内存池中的内存，以便系统释放资源。

16. 内存池管理器：内存池管理器是指在程序运行过程中，管理内存池，确保内存池中的内存分配和释放正确。

17. 内存池分配器：内存池分配器是指在程序运行过程中，从内存池中分配内存，以节省内存分配的时间。

18. 内存池释放器：内存池释放器是指在程序运行过程中，释放不再使用的内存，以便系统回收资源。

19. 内存池回收器：内存池回收器是指在程序运行过程中，回收内存池中的内存，以便系统释放资源。

20. 内存池管理器：内存池管理器是指在程序运行过程中，管理内存池，确保内存池中的内存分配和释放正确。

#汇编语言

1. 汇编语言：汇编语言是指用助记符或机器指令来表示计算机指令的语言。

2. 汇编器：汇编器是指将汇编语言程序转换为机器语言程序的程序。

3. 汇编程序：汇编程序是指用汇编语言编写的程序。

4. 汇编指令：汇编指令是指用助记符或机器指令来表示计算机指令的语言。

5. 汇编语句：汇编语句是指用汇编语言编写的程序语句。

6. 汇编程序结构：汇编程序结构是指汇编程序的基本结构。

7. 汇编程序优化：汇编程序优化是指对汇编程序进行优化，提高程序运行效率。

8. 汇编程序调试：汇编程序调试是指对汇编程序进行调试，找出程序中的错误。

9. 汇编程序优化技术：汇编程序优化技术是指对汇编程序进行优化的技术。

10. 汇编程序优化方法：汇编程序优化方法是指对汇编程序进行优化的方法。

11. 汇编程序优化工具：汇编程序优化工具是指对汇编程序进行优化的工具。

12. 汇编程序优化策略：汇编程序优化策略是指对汇编程序进行优化的策略。

13. 汇编程序优化原理：汇编程序优化原理是指对汇编程序进行优化的原理。

14. 汇编程序优化步骤：汇编程序优化步骤是指对汇编程序进行优化的步骤。


#内存操作实战

1.下载Cheat Engine，一个开源的内存分析工具。
url:https://www.cheatengine.org/downloads.php

2.打开Cheat Engine，选择一个进程，点击“Start”按钮。
这里以crossfire.exe为例。
进入游戏房间，选择4字节，输入当前主弹夹的数量，点击首次扫描
我们看到有好多的地址，要记住真实的基址是包含"cshell.dll"模块
"cshell.dll"+016B3FD0就是人物基址
右键此地址，选择"反汇编此内存区域"
这个时候就会打开一个新的窗口，显示了这个地址的汇编代码
你可以看到类似的指令：(虚构，实际的内存地址可能不同)

016B3FD0  mov     eax, [cshell.dll+016B3F9C]
016B3FD6  mov     [cshell.dll+016B3F9C], eax
016B3FDA  mov     eax, [cshell.dll+016B3F9C]
016B3FDF  mov     [cshell.dll+016B3F9C], eax

到这了，我们就要引用汇编指令的用法了

#常用汇编指令

1.MOV - 数据传送指令，用于在寄存器之间或寄存器与内存之间传送数据。
MOV AX, BX            ; 将BX中的数据传送到AX中
MOV CX, 10H           ; 将16进制数10H传送到CX中
MOV [SI], AX          ; 将AX中的数据传送到SI指向的内存地址

2.ADD - 加法指令，用于将两个操作数相加并将结果放到第一个操作数中。
ADD AX, BX            ; AX = AX + BX
ADD AX, 10H           ; AX = AX + 10H

3.SUB - 减法指令，用于将两个操作数相减并将结果放到第一个操作数中。
SUB AX, BX            ; AX = AX - BX
SUB AX, 10H           ; AX = AX - 10H

4.INC - 加1指令，用于将操作数加1。
INC AX                ; AX = AX + 1

5.DEC - 减1指令，用于将操作数减1。
DEC AX                ; AX = AX - 1

6.CMP - 比较指令，用于比较两个操作数的值，并设置标志寄存器。
CMP AX, BX            ; 如果AX = BX，则设置标志寄存器的进位标志（CF）
CMP AX, 10H           ; 如果AX = 10H，则设置标志寄存器的进位标志（CF）

7.JMP - 转移指令，用于无条件转移到指定位置。
JMP 0100H            ; 无条件转移到内存地址0100H

8.JE 或 JZ - 等于跳转指令，如果最近一次比较结果为相等，则跳转。
CMP AX, BX            ; 比较AX和BX
JE Label              ; 如果相等，则跳转到Label处

9.JNE 或 JNZ - 不等于跳转指令，如果最近一次比较结果不相等，则跳转。
CMP AX, BX            ; 比较AX和BX
JNE Label             ; 如果不相等，则跳转到Label处

10.CALL - 调用子程序指令，保存当前指令地址到堆栈，并跳转到子程序地址。
CALL Subroutine       ; 调用子程序Subroutine
//顺带一提 CALL Send 可用来直接调用到Send函数，破除防护

11.RET - 返回指令，从堆栈中弹出返回地址，并跳转到该地址继续执行。
RET                   ; 从子程序返回

12.AND - 逻辑与指令，用于对两个操作数进行按位AND运算，并将结果放到第一个操作数中。
AND AX, BX            ; AX = AX AND BX
AND AX, 0FF00H        ; AX = AX AND 0FF00H

13.OR - 逻辑或指令，用于对两个操作数进行按位OR运算，并将结果放到第一个操作数中。
OR AX, BX             ; AX = AX OR BX
OR AX, 0FF00H         ; AX = AX OR 0FF00H

14.XOR - 逻辑异或指令，用于对两个操作数进行按位异或运算，并将结果放到第一个操作数中。
XOR AX, BX            ; AX = AX XOR BX
XOR AX, 0FF00H        ; AX = AX XOR 0FF00H

15.NOT - 逻辑非指令，用于对操作数进行按位取反运算。
NOT AX                ; AX = NOT AX

16.SHL - 逻辑左移指令，用于将操作数向左移动指定的位数。
SHL AX, 1             ; AX = AX << 1

17.SHR - 逻辑右移指令，用于将操作数向右移动指定的位数。
SHR AX, 1             ; AX = AX >> 1

18.PUSH - 推入栈指令，用于将操作数压入堆栈。
PUSH AX               ; 将AX压入堆栈
PUSH 10H              ; 将10H压入堆栈

19.POP - 弹出栈指令，用于从堆栈中弹出一个操作数。
POP AX                ; 从堆栈弹出AX

20.LEA - 取址指令，用于将一个内存地址放到一个寄存器中。
LEA AX, [SI+10H]      ; AX = SI + 10H



上面只是汇编指令的一些常用用法，实际上还有很多指令，具体用法请参考官方文档。
我这边比较常用的就是：mov,add,sub,call,cmp,je,jne,jmp,xor,or等。
那么我们怎么知道内存地址里面到底是什么呢？
这个时候就要引用一个新的概念：寄存器。

#寄存器

1.寄存器：寄存器是CPU中的一个小容量存储器，用来临时存储数据。

2.通用寄存器：通用寄存器是CPU中的寄存器，可以用来存储各种数据。

3.段寄存器：段寄存器是CPU中的寄存器，用来存储程序运行时段的起始地址。

4.指令指针寄存器：指令指针寄存器是CPU中的寄存器，用来存储当前程序执行的指令地址。

5.基址寄存器：基址寄存器是CPU中的寄存器，用来存储数据段的起始地址。

6.变址寄存器：变址寄存器是CPU中的寄存器，用来存储内存的偏移地址。

7.栈指针寄存器：栈指针寄存器是CPU中的寄存器，用来存储栈顶指针。

8.条件码寄存器：条件码寄存器是CPU中的寄存器，用来存储最近一次比较的结果。

9.标志寄存器：标志寄存器是CPU中的寄存器，用来存储CPU的状态信息。

10.堆栈寄存器：堆栈寄存器是CPU中的寄存器，用来存储临时数据。

11.段寄存器：段寄存器是CPU中的寄存器，用来存储程序运行时段的起始地址。

12.通用寄存器：通用寄存器是CPU中的寄存器，可以用来存储各种数据。

13.通用寄存器的分类：

- 通用寄存器：AX、BX、CX、DX、SI、DI、BP、SP
- 累加器：AL、AH、BL、BH、CL、CH、DL、DH
- 指针寄存器：ES、CS、SS、DS
- 指令指针寄存器：IP
- 标志寄存器：CF、PF、AF、ZF、SF、TF、IF、DF、OF

14.通用寄存器的用途：

- AX、BX、CX、DX：一般用来存储数据。
- SI、DI：一般用来存储内存地址。
- BP、SP：一般用来存储栈的地址。
- ES、CS、SS、DS：一般用来存储段的地址。
- IP：一般用来存储指令的地址。
- AL、AH、BL、BH、CL、CH、DL、DH：一般用来存储低位字节。
- CF、PF、AF、ZF、SF、TF、IF、DF、OF：一般用来存储状态信息。

15.通用寄存器的读写：

1.读通用寄存器：

- MOV AX, BX            ; 将BX中的数据传送到AX中
- MOV CX, 10H           ; 将16进制数10H传送到CX中
- MOV [SI], AX          ; 将AX中的数据传送到SI指向的内存地址

2.写通用寄存器：

- MOV BX, AX            ; 将AX中的数据传送到BX中
- MOV [SI], 10H         ; 将16进制数10H写入SI指向的内存地址
- MOV [SI], AX          ; 将AX中的数据写入SI指向的内存地址

3.读段寄存器：

- MOV AX, ES            ; 将ES中的段地址传送到AX中
- MOV AX, CS            ; 将CS中的段地址传送到AX中
- MOV AX, SS            ; 将SS中的段地址传送到AX中
- MOV AX, DS            ; 将DS中的段地址传送到AX中

4.写段寄存器：

- MOV ES, AX            ; 将AX中的段地址传送到ES中
- MOV CS, AX            ; 将AX中的段地址传送到CS中
- MOV SS, AX            ; 将AX中的段地址传送到SS中
- MOV DS, AX            ; 将AX中的段地址传送到DS中

5.读指令指针寄存器：

- MOV AX, IP            ; 将IP中的指令地址传送到AX中

6.写指令指针寄存器：

- MOV IP, AX            ; 将AX中的指令地址传送到IP中

7.读基址寄存器：

- MOV AX, BX            ; 将BX中的数据传送到AX中
- MOV AX, [BX]          ; 将BX指向的内存地址中的数据传送到AX中

8.写基址寄存器：

- MOV BX, AX            ; 将AX中的数据传送到BX中
- MOV [BX], AX          ; 将AX中的数据写入BX指向的内存地址

9.读变址寄存器：

- MOV AX, BX            ; 将BX中的数据传送到AX中
- MOV AX, [BX+SI]       ; 将BX+SI指向的内存地址中的数据传送到AX中

10.写变址寄存器：

- MOV BX, AX            ; 将AX中的数据传送到BX中
- MOV [BX+SI], AX       ; 将AX中的数据写入BX+SI指向的内存地址

11.读栈指针寄存器：

1.PUSH：

- PUSH AX               ; 将AX压入堆栈
- PUSH 10H              ; 将10H压入堆栈

2.POP：

- POP AX                ; 从堆栈弹出AX

12.读条件码寄存器：

- CMP AX, BX            ; 比较AX和BX
- JE Label              ; 如果相等，则跳转到Label处

13.读标志寄存器：

1.设置标志寄存器：

- SETE AL               ; 设置AL的进位标志（CF）
- SETZ AL               ; 设置AL的零标志（ZF）
- SETC AL               ; 设置AL的进位标志（CF）
- SETA AL               ; 设置AL的辅助进位标志（AF）
- SETP AL               ; 设置AL的奇偶标志（PF）
- SETS AL               ; 设置AL的符号标志（SF）
- SETD AL               ; 设置AL的方向标志（DF）
- SETO AL               ; 设置AL的溢出标志（OF）

2.清除标志寄存器：

- CLC                   ; 清除CF标志
- CLZ                   ; 清除ZF标志
- CLC                   ; 清除CF标志
- CLA                   ; 清除AF标志
- CLP                   ; 清除PF标志
- CLS                   ; 清除SF标志
- CLD                   ; 清除DF标志
- CLO                   ; 清除OF标志
14.其他指令：

- INT 3                ; 触发断点
- INT 10H              ; 显示字符串
- INT 13H              ; 显示字符
- INT 21H              ; 系统调用
- INT 21H, 0           ; 打开文件
- INT 21H, 1           ; 关闭文件
- INT 21H, 2           ; 读文件
- INT 21H, 3           ; 写文件
- INT 21H, 4           ; 定位文件
- INT 21H, 5           ; 读目录
- INT 21H, 6           ; 创建文件
- INT 21H, 7           ; 重命名文件
- INT 21H, 8           ; 删除文件
- INT 21H, 9           ; 复制文件
- INT 21H, 10          ; 获得文件信息
- INT 21H, 11          ; 获得当前目录
- INT 21H, 12          ; 获得当前磁盘
- INT 21H, 13          ; 获得当前日期
- INT 21H, 14          ; 获得当前时间
- INT 21H, 15          ; 获得当前时间和日期
- INT 21H, 16          ; 获得文件长度
- INT 21H, 17          ; 获得文件属性
- INT 21H, 18          ; 设置文件属性
- INT 21H, 19          ; 获得当前驱动器号

